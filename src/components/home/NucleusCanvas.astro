---
import travel from '@data/travel.json';
import tags from '@data/writing-tags.json';
import cycling from '@data/cycling.json';

const constellationLabels = [
  ...travel.map((item) => item.place),
  ...tags,
  `MI ${cycling.thisMonth.miles}`,
  `FT ${cycling.thisMonth.elevation}`,
  `RIDES ${cycling.thisMonth.rides ?? 0}`
].slice(0, 22);
---

<canvas class="nucleus-canvas" data-nucleus-canvas data-labels={JSON.stringify(constellationLabels)} aria-hidden="true"></canvas>

<style>
  .nucleus-canvas { position:absolute; inset:0; width:100%; height:100%; z-index:0; }
</style>

<script>
  // @ts-nocheck
  const canvas = document.querySelector('[data-nucleus-canvas]');
  if (canvas instanceof HTMLCanvasElement) {
    const ctx = canvas.getContext('2d');
    if (ctx instanceof CanvasRenderingContext2D) {
    const reduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const labels = JSON.parse(canvas.dataset.labels ?? '[]');
    let w = 0; let h = 0; let t = 0; let view = 0; let lastFrame = 0;
    let pointer = { x: 0.5, y: 0.5, active: false };
    const styles = getComputedStyle(document.documentElement);
    const accent = styles.getPropertyValue('--accent-primary').trim();
    const border = styles.getPropertyValue('--border').trim();
    const textTertiary = styles.getPropertyValue('--text-tertiary').trim();

    // tiny simplex-ish noise, MIT-style compact variant
    const perm = new Uint8Array(512);
    for (let i = 0; i < 256; i += 1) perm[i] = i;
    for (let i = 255; i > 0; i -= 1) { const j = Math.floor(Math.random() * (i + 1)); [perm[i], perm[j]] = [perm[j], perm[i]]; }
    for (let i = 0; i < 256; i += 1) perm[i + 256] = perm[i];
    const grad = (h, x, y) => (((h & 1) ? -x : x) + ((h & 2) ? -y : y));
    const noise2 = (x, y) => {
      const X = Math.floor(x) & 255; const Y = Math.floor(y) & 255;
      const xf = x - Math.floor(x); const yf = y - Math.floor(y);
      const u = xf * xf * (3 - 2 * xf); const v = yf * yf * (3 - 2 * yf);
      const aa = perm[X + perm[Y]], ab = perm[X + perm[Y + 1]], ba = perm[X + 1 + perm[Y]], bb = perm[X + 1 + perm[Y + 1]];
      const x1 = grad(aa, xf, yf) + u * (grad(ba, xf - 1, yf) - grad(aa, xf, yf));
      const x2 = grad(ab, xf, yf - 1) + u * (grad(bb, xf - 1, yf - 1) - grad(ab, xf, yf - 1));
      return (x1 + v * (x2 - x1));
    };

    const constellation = labels.map((label) => ({ label, x: Math.random(), y: Math.random(), vx: 0, vy: 0, hi: Math.random() > 0.82 }));

    const meshVertices = Array.from({ length: 96 }, (_, i) => {
      const a = (i / 96) * Math.PI * 2;
      const b = ((i % 24) / 24) * Math.PI;
      return { a, b, ox: 0, oy: 0 };
    });

    const resize = () => {
      const r = canvas.getBoundingClientRect(); w = r.width; h = r.height;
      canvas.width = Math.floor(w * devicePixelRatio); canvas.height = Math.floor(h * devicePixelRatio);
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    };

    const clear = () => { ctx.clearRect(0, 0, w, h); };

    const drawMesh = () => {
      const cx = w / 2; const cy = h / 2; const radius = Math.min(w, h) * 0.22;
      const points = meshVertices.map((v, i) => {
        const n = noise2(Math.cos(v.a) * 1.3 + t * 0.001, Math.sin(v.b) * 1.3 + t * 0.0013);
        const rr = radius + n * 18;
        let x = Math.sin(v.b) * Math.cos(v.a + t * 0.0003) * rr;
        let y = Math.cos(v.b) * rr;
        const z = Math.sin(v.b) * Math.sin(v.a + t * 0.0003) * rr;
        if (pointer.active) {
          const px = (pointer.x - 0.5) * 40; const py = (pointer.y - 0.5) * 30;
          x += px * 0.12; y += py * 0.12;
        }
        const depth = 240 / (240 + z);
        return { x: cx + x * depth, y: cy + y * depth, z };
      });
      ctx.strokeStyle = `${border}55`; ctx.lineWidth = 0.8;
      for (let i = 0; i < points.length; i += 1) {
        for (let j = i + 1; j < points.length; j += 1) {
          const d = Math.hypot(points[i].x - points[j].x, points[i].y - points[j].y);
          if (d < 28) { ctx.beginPath(); ctx.moveTo(points[i].x, points[i].y); ctx.lineTo(points[j].x, points[j].y); ctx.stroke(); }
        }
      }
      ctx.fillStyle = accent;
      points.forEach((p) => { ctx.globalAlpha = 0.35; ctx.beginPath(); ctx.arc(p.x, p.y, 1.5, 0, Math.PI * 2); ctx.fill(); });
      ctx.globalAlpha = 1;
    };

    const drawTopo = () => {
      const levels = 10;
      for (let l = 0; l < levels; l += 1) {
        const target = -0.7 + l * 0.14;
        ctx.strokeStyle = accent;
        ctx.globalAlpha = 0.08 + l * 0.03;
        ctx.lineWidth = 1;
        for (let y = 0; y < h; y += 10) {
          ctx.beginPath();
          let started = false;
          for (let x = 0; x < w; x += 6) {
            const n = noise2(x * 0.014 + t * 0.00025, y * 0.018 + t * 0.0002);
            if (Math.abs(n - target) < 0.05) {
              if (!started) { ctx.moveTo(x, y); started = true; } else { ctx.lineTo(x, y); }
            }
          }
          ctx.stroke();
        }
      }
      ctx.globalAlpha = 1;
    };

    const drawConstellation = () => {
      const breathe = 1 + Math.sin(t * 0.001) * 0.03;
      constellation.forEach((n, i) => {
        const tx = ((i % 6) + 1) / 7;
        const ty = (Math.floor(i / 6) + 1) / 5;
        n.vx += (tx - n.x) * 0.0008;
        n.vy += (ty - n.y) * 0.0008;
        n.vx *= 0.94; n.vy *= 0.94;
        n.x += n.vx; n.y += n.vy;
      });
      ctx.strokeStyle = `${border}66`; ctx.lineWidth = 0.7;
      for (let i = 0; i < constellation.length; i += 1) {
        for (let j = i + 1; j < constellation.length; j += 1) {
          const ax = constellation[i].x * w; const ay = constellation[i].y * h;
          const bx = constellation[j].x * w; const by = constellation[j].y * h;
          if (Math.hypot(ax - bx, ay - by) < 110) { ctx.beginPath(); ctx.moveTo(ax, ay); ctx.lineTo(bx, by); ctx.stroke(); }
        }
      }
      constellation.forEach((n, idx) => {
        const x = n.x * w * breathe; const y = n.y * h * breathe;
        ctx.fillStyle = n.hi ? accent : textTertiary;
        ctx.globalAlpha = n.hi ? 0.55 + Math.sin(t * 0.004 + idx) * 0.2 : 0.35;
        ctx.beginPath(); ctx.arc(x, y, n.hi ? 2 : 1.4, 0, Math.PI * 2); ctx.fill();
        ctx.font = "10px 'IBM Plex Mono'"; ctx.fillStyle = textTertiary; ctx.globalAlpha = 0.5; ctx.fillText(String(n.label).toUpperCase(), x + 5, y - 4);
      });
      ctx.globalAlpha = 1;
    };

    const drawWave = () => {
      ctx.strokeStyle = accent; ctx.lineWidth = 1.5; ctx.shadowBlur = 10; ctx.shadowColor = accent;
      ctx.beginPath();
      for (let x = 0; x <= w; x += 2) {
        const nx = x / w;
        const y = h * 0.5 + Math.sin(nx * 14 + t * 0.005) * 20 + Math.sin(nx * 30 - t * 0.003) * 8 + Math.sin(nx * 5 + t * 0.002) * 16;
        if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      ctx.stroke();
      ctx.shadowBlur = 0;
    };

    const drawByView = () => {
      clear();
      if (view === 0) drawMesh();
      else if (view === 1) drawTopo();
      else if (view === 2) drawConstellation();
      else drawWave();
    };

    const doGlitchTransition = () => {
      if (reduced) return;
      const snap = document.createElement('canvas');
      snap.width = canvas.width; snap.height = canvas.height;
      const sctx = snap.getContext('2d');
      if (!(sctx instanceof CanvasRenderingContext2D)) return;
      sctx.drawImage(canvas, 0, 0);
      const start = performance.now();
      const tick = (now) => {
        const elapsed = now - start;
        clear();
        for (let i = 0; i < 8; i += 1) {
          const sy = Math.random() * h;
          const sh = 4 + Math.random() * 14;
          const dx = (Math.random() - 0.5) * 24;
          ctx.drawImage(snap, 0, sy, w, sh, dx, sy, w, sh);
        }
        ctx.fillStyle = `${accent}22`; ctx.fillRect(0, 0, w, h);
        if (elapsed < 200) requestAnimationFrame(tick);
      };
      requestAnimationFrame(tick);
    };

    const animate = (now) => {
      if (!reduced && now - lastFrame < 33) { requestAnimationFrame(animate); return; }
      lastFrame = now; t = now; drawByView();
      if (!reduced) requestAnimationFrame(animate);
    };

    resize(); drawByView();
    if (!reduced) {
      requestAnimationFrame(animate);
      setInterval(() => {
        doGlitchTransition();
        setTimeout(() => { view = (view + 1) % 4; }, 200);
      }, 32000);
    }
    window.addEventListener('resize', resize);
    canvas.addEventListener('pointermove', (e) => {
      const r = canvas.getBoundingClientRect();
      pointer = { x: (e.clientX - r.left) / r.width, y: (e.clientY - r.top) / r.height, active: true };
    });
    canvas.addEventListener('pointerleave', () => { pointer.active = false; });
    }
  }
</script>
