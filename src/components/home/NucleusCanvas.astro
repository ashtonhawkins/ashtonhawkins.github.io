<canvas class="nucleus-canvas" data-nucleus-canvas aria-hidden="true"></canvas>

<style>
  .nucleus-canvas { position:absolute; inset:0; width:100%; height:100%; z-index:0; }
</style>

<script>
  // @ts-nocheck
  const canvas = document.querySelector('[data-nucleus-canvas]');
  if (canvas instanceof HTMLCanvasElement) {
    const ctx = canvas.getContext('2d');
    if (ctx instanceof CanvasRenderingContext2D) {
      const reduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const cities = [
        { name: 'Tokyo', profile: [34,58,44,78,52,40,66,32], mark: 'triangle' },
        { name: 'London', profile: [30,42,76,38,62,46,50,40], mark: 'spire' },
        { name: 'Paris', profile: [26,50,34,80,44,58,36,42], mark: 'tower' },
        { name: 'Lisbon', profile: [28,54,40,64,48,38,56,30], mark: 'arch' }
      ];
      const destinations = [[35.6762,139.6503],[51.5074,-0.1278],[38.7223,-9.1393],[64.1466,-21.9426],[48.8566,2.3522],[19.4326,-99.1332],[55.6761,12.5683]];
      const sfo = [37.6213,-122.3790];
      let w=0,h=0,t=0,last=0,view=0,rot=0,mouse=0,cityIndex=0,morph=0;

      const styles = () => getComputedStyle(document.documentElement);
      const col = () => ({ accent: styles().getPropertyValue('--accent-primary').trim(), border: styles().getPropertyValue('--border').trim(), tertiary: styles().getPropertyValue('--text-tertiary').trim() });

      // compact simplex noise (MIT-style)
      const grad3=[[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];
      const p=Array.from({length:256},(_,i)=>i); for(let i=255;i>0;i--){const n=(Math.random()*(i+1))|0;[p[i],p[n]]=[p[n],p[i]]}
      const perm=Array.from({length:512},(_,i)=>p[i&255]);
      const dot=(g,x,y)=>g[0]*x+g[1]*y;
      const noise2=(xin,yin)=>{const F2=0.5*(Math.sqrt(3)-1),G2=(3-Math.sqrt(3))/6; const s=(xin+yin)*F2; const i=Math.floor(xin+s),j=Math.floor(yin+s); const t=(i+j)*G2; const X0=i-t,Y0=j-t; const x0=xin-X0,y0=yin-Y0; const i1=x0>y0?1:0,j1=x0>y0?0:1; const x1=x0-i1+G2,y1=y0-j1+G2,x2=x0-1+2*G2,y2=y0-1+2*G2; const ii=i&255,jj=j&255; const gi0=perm[ii+perm[jj]]%8,gi1=perm[ii+i1+perm[jj+j1]]%8,gi2=perm[ii+1+perm[jj+1]]%8; let n0=0,n1=0,n2=0; let q=0.5-x0*x0-y0*y0; if(q>0){q*=q;n0=q*q*dot(grad3[gi0],x0,y0)} q=0.5-x1*x1-y1*y1; if(q>0){q*=q;n1=q*q*dot(grad3[gi1],x1,y1)} q=0.5-x2*x2-y2*y2; if(q>0){q*=q;n2=q*q*dot(grad3[gi2],x2,y2)} return 70*(n0+n1+n2); };

      const resize=()=>{const r=canvas.getBoundingClientRect(); w=r.width; h=r.height; canvas.width=w*devicePixelRatio; canvas.height=h*devicePixelRatio; ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0)};
      const clear=()=>ctx.clearRect(0,0,w,h);

      const drawTopo=()=>{const {accent}=col(); for(let l=0;l<13;l++){const target=-0.8+l*0.13; ctx.strokeStyle=accent; ctx.globalAlpha=0.08+l*0.02; for(let y=0;y<h;y+=8){ctx.beginPath();let open=false; for(let x=0;x<w;x+=4){const n=noise2((x/w)*7+t*0.00004,(y/h)*14+t*0.00003)+noise2((x/w)*2+t*0.00002,(y/h)*3)*0.6; if(Math.abs(n-target)<0.05){if(!open){ctx.moveTo(x,y);open=true}else ctx.lineTo(x,y)}} ctx.stroke();}} ctx.globalAlpha=1;};

      const proj=(lat,lng,radius,ry)=>{const la=lat*Math.PI/180, lo=(lng*Math.PI/180)+ry; const x=Math.cos(la)*Math.cos(lo), y=Math.sin(la), z=Math.cos(la)*Math.sin(lo); const d=2.4/(2.4-z); return [x*radius*d+w*0.5,y*radius*d+h*0.46,z];};
      const drawGlobe=()=>{const {accent,border,tertiary}=col(); const r=Math.min(w,h)*0.24; ctx.strokeStyle=border; ctx.globalAlpha=.2; for(let lat=-75;lat<=75;lat+=15){ctx.beginPath(); for(let lng=-180;lng<=180;lng+=8){const [x,y,z]=proj(lat,lng,r,rot); if(lng===-180||z<0)ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.stroke();} for(let lng=-180;lng<180;lng+=15){ctx.beginPath(); for(let lat=-90;lat<=90;lat+=6){const [x,y,z]=proj(lat,lng,r,rot); if(lat===-90||z<0)ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.stroke();}
        ctx.strokeStyle=tertiary; ctx.globalAlpha=.3; [[20,-130],[50,-100],[55,5],[35,20],[30,110],[0,120]].forEach((p,i)=>{const [x,y,z]=proj(p[0],p[1],r,rot); if(i===0||z<0)ctx.moveTo(x,y); else ctx.lineTo(x,y);}); ctx.stroke();
        ctx.strokeStyle=accent; ctx.globalAlpha=.4; destinations.forEach(([la,lo])=>{ctx.beginPath(); for(let i=0;i<=40;i++){const a=i/40; const cl=sfo[0]*(1-a)+la*a; const cg=sfo[1]*(1-a)+lo*a; const [x,y,z]=proj(cl,cg,r,rot); if(i===0||z<0)ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.stroke(); const [dx,dy]=proj(la,lo,r,rot); ctx.fillStyle=accent; ctx.globalAlpha=.9; ctx.beginPath(); ctx.arc(dx,dy,2,0,Math.PI*2); ctx.fill();}); ctx.globalAlpha=1;};

      const drawSkyline=()=>{const {accent}=col(); const a=cities[cityIndex%cities.length].profile,b=cities[(cityIndex+1)%cities.length].profile; const base=h*0.82; const bw=w/a.length; for(let i=0;i<a.length;i++){const hh=(a[i]*(1-morph)+b[i]*morph); const x=i*bw,y=base-hh; ctx.fillStyle=accent; ctx.globalAlpha=.15; ctx.fillRect(x,y,bw-2,hh); ctx.strokeStyle=accent; ctx.globalAlpha=.3; ctx.strokeRect(x,y,bw-2,hh);} for(let i=0;i<18;i++){ctx.fillStyle=accent; ctx.globalAlpha=.2+.2*Math.sin(t*0.002+i); ctx.fillRect((i*53)%w,(i*37)%Math.max(1,base-20),1.5,1.5);} ctx.globalAlpha=.1; ctx.save(); ctx.translate(0,base*2); ctx.scale(1,-1); ctx.fillRect(0,base,w,base*0.25); ctx.restore(); ctx.globalAlpha=1;};

      const drawWave=()=>{const {accent,border}=col(); const y0=h*0.42; ctx.strokeStyle=accent; ctx.shadowBlur=6; ctx.shadowColor=accent; ctx.lineWidth=1.5; ctx.beginPath(); for(let x=0;x<=w;x+=2){const nx=x/w; const y=y0+Math.sin(nx*6+t*0.001)*16+Math.sin(nx*14+t*0.0017)*8+Math.sin(nx*24-t*0.0013)*6; if(!x)ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.stroke(); ctx.shadowBlur=0; ctx.globalAlpha=.3; ctx.beginPath(); for(let x=0;x<=w;x+=2){const nx=x/w; const y=y0+2+Math.sin(nx*6+t*0.0015+0.5)*12+Math.sin(nx*12+t*0.0012)*6; if(!x)ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.stroke(); ctx.globalAlpha=1; for(let i=0;i<10;i++){const bh=8+Math.sin(t*0.001+i)*8; ctx.fillStyle=border; ctx.globalAlpha=.35; ctx.fillRect(10+i*((w-20)/10),h-12-bh,2,bh);} ctx.globalAlpha=1;};

      const draw=()=>{clear(); if(view===0)drawTopo(); if(view===1)drawGlobe(); if(view===2)drawSkyline(); if(view===3)drawWave();};
      const glitch=()=>{if(reduced)return; const snap=document.createElement('canvas'); snap.width=canvas.width; snap.height=canvas.height; const s=snap.getContext('2d'); if(!s)return; s.drawImage(canvas,0,0); const start=performance.now(); const tick=(n)=>{clear(); for(let i=0;i<7;i++){const sy=Math.random()*h,sh=5+Math.random()*12,dx=(Math.random()-.5)*22; ctx.drawImage(snap,0,sy,w,sh,dx,sy,w,sh);} ctx.fillStyle=`${col().accent}22`; ctx.fillRect(0,0,w,h); if(n-start<200)requestAnimationFrame(tick);}; requestAnimationFrame(tick);};
      const step=(n)=>{if(document.hidden) return requestAnimationFrame(step); if(!reduced&&n-last<33) return requestAnimationFrame(step); last=n; t=n; rot+=0.0009+mouse; morph=(Math.sin(n*0.00025)+1)/2; draw(); if(!reduced)requestAnimationFrame(step);};

      resize(); draw();
      if(!reduced){requestAnimationFrame(step); setInterval(()=>{glitch(); setTimeout(()=>{view=(view+1)%4; if(view===2)cityIndex=(cityIndex+1)%cities.length;},200)},34000);}      
      canvas.addEventListener('pointermove',(e)=>{const r=canvas.getBoundingClientRect(); mouse=((e.clientX-r.left)/r.width-.5)*0.0015;});
      canvas.addEventListener('pointerleave',()=>{mouse=0;});
      window.addEventListener('resize',resize);
    }
  }
</script>
