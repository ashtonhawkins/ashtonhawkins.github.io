<canvas id="nucleus-canvas" class="nucleus-canvas" aria-hidden="true"></canvas>

<style>
  .nucleus-canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
  }
</style>

<script>
  // @ts-nocheck
  const canvas = document.getElementById('nucleus-canvas');
  const ctx = canvas?.getContext('2d');

  if (canvas instanceof HTMLCanvasElement && ctx instanceof CanvasRenderingContext2D) {
    const SLIDES = [
      { visual: 'topo', label: 'CYCLING', detail: 'Last Ride: 23 mi / 1,400 ft', link: '#cycling' },
      { visual: 'globe', label: 'TRAVEL', detail: 'Latest: SFO → NRT · 7 countries', link: '#travel' },
      { visual: 'skyline', label: 'TRAVEL', detail: '24 flights · 142,000 mi', link: '#travel' },
      { visual: 'waveform', label: 'CONSUMPTION', detail: 'Listening · Awaiting feed sync', link: '#consumption' }
    ];
    let currentSlide = 0;
    let time = 0;
    let transitioning = false;

    const DESTINATIONS = [
      { name: 'Tokyo', lat: 35.6762, lng: 139.6503 },
      { name: 'London', lat: 51.5074, lng: -0.1278 },
      { name: 'Lisbon', lat: 38.7223, lng: -9.1393 },
      { name: 'Reykjavik', lat: 64.1466, lng: -21.9426 },
      { name: 'Paris', lat: 48.8566, lng: 2.3522 },
      { name: 'Mexico City', lat: 19.4326, lng: -99.1332 },
      { name: 'Copenhagen', lat: 55.6761, lng: 12.5683 }
    ];
    const SFO = { lat: 37.6213, lng: -122.3790 };

    const SKYLINES = {
      Tokyo: [[5, 30], [8, 45], [12, 60], [16, 85], [19, 40], [23, 35], [27, 50], [31, 70], [35, 45], [40, 55], [45, 65], [50, 90], [54, 50], [58, 40], [62, 55], [66, 45], [70, 60], [75, 40], [80, 50], [85, 35], [90, 45], [95, 30]],
      London: [[5, 25], [10, 35], [15, 30], [20, 45], [25, 40], [30, 55], [35, 80], [38, 95], [41, 80], [45, 50], [50, 45], [55, 60], [60, 50], [65, 40], [70, 55], [75, 35], [80, 45], [85, 30], [90, 35], [95, 25]],
      Paris: [[5, 30], [10, 35], [15, 40], [20, 45], [22, 50], [25, 55], [28, 60], [31, 65], [34, 70], [38, 80], [42, 100], [46, 80], [50, 70], [54, 65], [58, 60], [62, 55], [66, 50], [70, 45], [75, 40], [80, 35], [85, 35], [90, 30], [95, 25]],
      Reykjavik: [[5, 15], [12, 20], [20, 30], [28, 25], [35, 40], [40, 55], [45, 35], [52, 20], [60, 30], [68, 25], [75, 35], [82, 20], [90, 15], [95, 10]]
    };
    const SKYLINE_KEYS = Object.keys(SKYLINES);
    let currentSkyline = 0;
    let nextSkyline = 1;
    let skylineLerp = 0;

    const getColors = () => {
      const style = getComputedStyle(document.documentElement);
      return {
        accent: style.getPropertyValue('--accent-primary').trim(),
        border: style.getPropertyValue('--border').trim()
      };
    };

    const grad3 = [[1, 1], [-1, 1], [1, -1], [-1, -1], [1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [-1, 1], [1, -1], [-1, -1]];
    const p = Array.from({ length: 256 }, (_, i) => i);
    for (let i = 255; i > 0; i--) {
      const r = Math.floor(Math.random() * (i + 1));
      [p[i], p[r]] = [p[r], p[i]];
    }
    const perm = Array.from({ length: 512 }, (_, i) => p[i & 255]);
    const dot = (g, x, y) => g[0] * x + g[1] * y;
    const noise2D = (xin, yin) => {
      const F2 = 0.5 * (Math.sqrt(3) - 1);
      const G2 = (3 - Math.sqrt(3)) / 6;
      const s = (xin + yin) * F2;
      const i = Math.floor(xin + s);
      const j = Math.floor(yin + s);
      const t = (i + j) * G2;
      const X0 = i - t;
      const Y0 = j - t;
      const x0 = xin - X0;
      const y0 = yin - Y0;
      const i1 = x0 > y0 ? 1 : 0;
      const j1 = x0 > y0 ? 0 : 1;
      const x1 = x0 - i1 + G2;
      const y1 = y0 - j1 + G2;
      const x2 = x0 - 1 + 2 * G2;
      const y2 = y0 - 1 + 2 * G2;
      const ii = i & 255;
      const jj = j & 255;
      const gi0 = perm[ii + perm[jj]] % 12;
      const gi1 = perm[ii + i1 + perm[jj + j1]] % 12;
      const gi2 = perm[ii + 1 + perm[jj + 1]] % 12;
      let n0 = 0; let n1 = 0; let n2 = 0;
      let q = 0.5 - x0 * x0 - y0 * y0;
      if (q > 0) { q *= q; n0 = q * q * dot(grad3[gi0], x0, y0); }
      q = 0.5 - x1 * x1 - y1 * y1;
      if (q > 0) { q *= q; n1 = q * q * dot(grad3[gi1], x1, y1); }
      q = 0.5 - x2 * x2 - y2 * y2;
      if (q > 0) { q *= q; n2 = q * q * dot(grad3[gi2], x2, y2); }
      return 70 * (n0 + n1 + n2);
    };

    const resizeCanvas = () => {
      const parent = canvas.parentElement;
      if (!parent) return;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = parent.clientWidth * dpr;
      canvas.height = parent.clientHeight * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    };

    const drawTopo = (w, h) => {
      const { accent } = getColors();
      ctx.clearRect(0, 0, w, h);
      const LEVELS = 12;
      const RESOLUTION = 3;
      const cols = Math.ceil(w / RESOLUTION);
      const rows = Math.ceil(h / RESOLUTION);
      const grid = [];

      for (let y = 0; y < rows; y++) {
        grid[y] = [];
        for (let x = 0; x < cols; x++) {
          let val = 0;
          val += noise2D(x * 0.02 + time * 0.0003, y * 0.035) * 0.6;
          val += noise2D(x * 0.05 + time * 0.0005, y * 0.08) * 0.3;
          val += noise2D(x * 0.1, y * 0.15 + time * 0.0002) * 0.1;
          grid[y][x] = val;
        }
      }

      for (let level = 0; level < LEVELS; level++) {
        const threshold = -0.5 + level / LEVELS;
        ctx.strokeStyle = accent;
        ctx.globalAlpha = 0.08 + (level / LEVELS) * 0.27;
        ctx.lineWidth = 0.8;
        ctx.beginPath();
        for (let y = 0; y < rows - 1; y++) {
          for (let x = 0; x < cols - 1; x++) {
            const tl = grid[y][x] > threshold ? 1 : 0;
            const tr = grid[y][x + 1] > threshold ? 1 : 0;
            const bl = grid[y + 1][x] > threshold ? 1 : 0;
            const br = grid[y + 1][x + 1] > threshold ? 1 : 0;
            const config = tl * 8 + tr * 4 + br * 2 + bl;
            if (config !== 0 && config !== 15) {
              const px = x * RESOLUTION;
              const py = y * RESOLUTION;
              ctx.moveTo(px, py);
              ctx.lineTo(px + RESOLUTION, py + RESOLUTION);
            }
          }
        }
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    };

    const project3D = (lat, lng, rotation, cx, cy, radius) => {
      const phi = ((90 - lat) * Math.PI) / 180;
      const theta = ((lng + rotation) * Math.PI) / 180;
      const x = radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.cos(phi);
      const z = radius * Math.sin(phi) * Math.sin(theta);
      const scale = 300 / (300 + z);
      return { x: cx + x * scale, y: cy - y * scale, z, visible: z > -radius * 0.2 };
    };

    const drawGlobe = (w, h) => {
      const { accent, border } = getColors();
      ctx.clearRect(0, 0, w, h);
      const cx = w * 0.55;
      const cy = h * 0.45;
      const radius = h * 0.42;
      const rotation = time * 0.01;

      ctx.strokeStyle = border;
      ctx.globalAlpha = 0.3;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.stroke();

      ctx.globalAlpha = 0.12;
      for (let lat = -60; lat <= 60; lat += 30) {
        ctx.beginPath();
        for (let lng = 0; lng <= 360; lng += 5) {
          const p = project3D(lat, lng, rotation, cx, cy, radius);
          if (lng === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
      }
      for (let lng = 0; lng < 360; lng += 30) {
        ctx.beginPath();
        for (let lat = -90; lat <= 90; lat += 5) {
          const p = project3D(lat, lng, rotation, cx, cy, radius);
          if (lat === -90) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
      }

      ctx.globalAlpha = 1;
      DESTINATIONS.forEach((dest) => {
        const p = project3D(dest.lat, dest.lng, rotation, cx, cy, radius);
        if (!p.visible) return;
        ctx.fillStyle = accent;
        ctx.shadowColor = accent;
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      });

      ctx.strokeStyle = accent;
      ctx.globalAlpha = 0.35;
      ctx.lineWidth = 1;
      DESTINATIONS.forEach((dest) => {
        ctx.beginPath();
        for (let t = 0; t <= 1; t += 0.02) {
          const lat = SFO.lat + (dest.lat - SFO.lat) * t;
          const lng = SFO.lng + (dest.lng - SFO.lng) * t;
          const altitude = 1 + Math.sin(t * Math.PI) * 0.15;
          const p = project3D(lat, lng, rotation, cx, cy, radius * altitude);
          if (t === 0) ctx.moveTo(p.x, p.y);
          else if (p.visible) ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
      });
      ctx.globalAlpha = 1;
    };

    const drawSkyline = (w, h) => {
      const { accent } = getColors();
      ctx.clearRect(0, 0, w, h);
      const currentData = SKYLINES[SKYLINE_KEYS[currentSkyline]];
      const nextData = SKYLINES[SKYLINE_KEYS[nextSkyline]];
      const baseY = h * 0.92;
      const maxBuildingH = h * 0.8;

      skylineLerp += 0.0008;
      if (skylineLerp >= 1) {
        skylineLerp = 0;
        currentSkyline = nextSkyline;
        nextSkyline = (nextSkyline + 1) % SKYLINE_KEYS.length;
      }

      const tt = skylineLerp;
      const ease = tt < 0.5 ? 2 * tt * tt : 1 - Math.pow(-2 * tt + 2, 2) / 2;
      const maxBuildings = Math.max(currentData.length, nextData.length);
      ctx.strokeStyle = accent;
      ctx.lineWidth = 1;

      for (let i = 0; i < maxBuildings; i++) {
        const c = currentData[i % currentData.length];
        const n = nextData[i % nextData.length];
        const xPct = c[0] + (n[0] - c[0]) * ease;
        const hPct = c[1] + (n[1] - c[1]) * ease;
        const bx = maxBuildings > 1 ? (i / (maxBuildings - 1)) * w : w / 2;
        const bh = (hPct / 100) * maxBuildingH;
        const bw = Math.max(6, (w / maxBuildings) * 0.85 + (xPct / 100) * 2);

        ctx.fillStyle = accent;
        ctx.globalAlpha = 0.12;
        ctx.fillRect(bx - bw / 2, baseY - bh, bw, bh);
        ctx.globalAlpha = 0.25;
        ctx.strokeRect(bx - bw / 2, baseY - bh, bw, bh);
      }

      ctx.globalAlpha = 1;
      for (let i = 0; i < 30; i++) {
        const sx = ((noise2D(i * 100, 0) + 1) / 2) * w;
        const sy = ((noise2D(0, i * 100) + 1) / 2) * h * 0.4;
        const twinkle = (Math.sin(time * 0.002 + i * 7) + 1) / 2;
        ctx.fillStyle = accent;
        ctx.globalAlpha = twinkle * 0.3;
        ctx.beginPath();
        ctx.arc(sx, sy, 1, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    };

    const drawWaveform = (w, h) => {
      const { accent } = getColors();
      ctx.clearRect(0, 0, w, h);
      const centerY = h * 0.5;
      const amplitude = h * 0.35;

      ctx.strokeStyle = accent;
      ctx.lineWidth = 2;
      ctx.shadowColor = accent;
      ctx.shadowBlur = 8;
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      for (let x = 0; x < w; x++) {
        const t = x / w;
        let y = 0;
        y += Math.sin(t * 6.28 * 2 + time * 0.001) * 0.45;
        y += Math.sin(t * 6.28 * 3.7 + time * 0.0015) * 0.25;
        y += Math.sin(t * 6.28 * 7.3 + time * 0.0008) * 0.15;
        y += Math.sin(t * 6.28 * 1.1 + time * 0.0005) * 0.5;
        y += noise2D(t * 3 + time * 0.0003, 0) * 0.12;
        const py = centerY + y * amplitude;
        if (x === 0) ctx.moveTo(x, py);
        else ctx.lineTo(x, py);
      }
      ctx.stroke();
      ctx.shadowBlur = 0;

      ctx.strokeStyle = accent;
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.25;
      ctx.beginPath();
      for (let x = 0; x < w; x++) {
        const t = x / w;
        let y = 0;
        y += Math.sin(t * 6.28 * 2 + time * 0.001 + 0.5) * 0.4;
        y += Math.sin(t * 6.28 * 3.7 + time * 0.0015 + 0.3) * 0.2;
        y += Math.sin(t * 6.28 * 7.3 + time * 0.0008 + 0.7) * 0.15;
        y += Math.sin(t * 6.28 * 1.1 + time * 0.0005 + 0.2) * 0.35;
        const py = centerY + y * (amplitude * 0.85) + 4;
        if (x === 0) ctx.moveTo(x, py);
        else ctx.lineTo(x, py);
      }
      ctx.stroke();

      ctx.globalAlpha = 0.2;
      const barCount = 10;
      const barWidth = 3;
      const barGap = w / (barCount + 1);
      const maxBarH = h * 0.35;
      for (let i = 0; i < barCount; i++) {
        const bx = barGap * (i + 1);
        const barH = h * 0.2 + Math.abs(Math.sin(time * 0.002 + i * 1.3)) * (maxBarH - h * 0.2);
        ctx.fillStyle = accent;
        ctx.fillRect(bx - barWidth / 2, h - barH, barWidth, barH);
      }
      ctx.globalAlpha = 1;
    };

    const glitchTransition = (w, h, callback) => {
      transitioning = true;
      const imageData = ctx.getImageData(0, 0, w, h);
      const start = performance.now();
      const duration = 200;

      const glitchStep = (now) => {
        ctx.putImageData(imageData, 0, 0);
        const slices = 5 + Math.floor(Math.random() * 10);
        for (let i = 0; i < slices; i++) {
          const y = Math.floor(Math.random() * h);
          const sliceH = 2 + Math.floor(Math.random() * 8);
          const offset = (Math.random() - 0.5) * 40;
          const slice = ctx.getImageData(0, y, w, sliceH);
          ctx.putImageData(slice, offset, y);
        }
        ctx.fillStyle = `rgba(${Math.random() > 0.5 ? 255 : 0}, ${Math.random() > 0.5 ? 255 : 0}, ${Math.random() > 0.5 ? 255 : 0}, 0.05)`;
        ctx.fillRect(0, 0, w, h);

        if (now - start < duration) requestAnimationFrame(glitchStep);
        else {
          callback();
          transitioning = false;
        }
      };
      requestAnimationFrame(glitchStep);
    };

    const updateCaption = (slideIndex) => {
      const slide = SLIDES[slideIndex];
      const labelEl = document.getElementById('nucleus-label');
      const detailEl = document.getElementById('nucleus-detail');
      const linkEl = document.getElementById('nucleus-link');

      if (labelEl) labelEl.textContent = slide.label;
      if (detailEl) detailEl.textContent = slide.detail;
      if (linkEl instanceof HTMLAnchorElement) linkEl.href = slide.link;

      document.querySelectorAll('.nucleus__dot').forEach((dot, i) => {
        dot.classList.toggle('nucleus__dot--active', i === slideIndex);
      });
    };

    const transitionToSlide = (nextIndex) => {
      const caption = document.getElementById('nucleus-caption');
      if (caption instanceof HTMLElement) caption.style.opacity = '0';

      const w = canvas.width / (window.devicePixelRatio || 1);
      const h = canvas.height / (window.devicePixelRatio || 1);
      glitchTransition(w, h, () => {
        currentSlide = nextIndex;
        updateCaption(nextIndex);
        if (caption instanceof HTMLElement) {
          window.setTimeout(() => {
            caption.style.opacity = '1';
          }, 100);
        }
      });
    };

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    updateCaption(0);

    const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const SLIDE_DURATION = 12000;
    let lastSwitch = Date.now();

    if (reducedMotion) {
      drawTopo(canvas.width / (window.devicePixelRatio || 1), canvas.height / (window.devicePixelRatio || 1));
    } else {
      document.querySelectorAll('.nucleus__dot').forEach((dot) => {
        dot.addEventListener('click', () => {
          const index = Number.parseInt(dot.getAttribute('data-dot') || '-1', 10);
          if (index >= 0 && index < SLIDES.length && index !== currentSlide && !transitioning) {
            lastSwitch = Date.now();
            transitionToSlide(index);
          }
        });
      });

      const animate = () => {
        time += 1;
        const w = canvas.width / (window.devicePixelRatio || 1);
        const h = canvas.height / (window.devicePixelRatio || 1);

        if (!transitioning) {
          const now = Date.now();
          if (now - lastSwitch > SLIDE_DURATION) {
            lastSwitch = now;
            const next = (currentSlide + 1) % SLIDES.length;
            transitionToSlide(next);
            return requestAnimationFrame(animate);
          }

          switch (SLIDES[currentSlide].visual) {
            case 'topo': drawTopo(w, h); break;
            case 'globe': drawGlobe(w, h); break;
            case 'skyline': drawSkyline(w, h); break;
            case 'waveform': drawWaveform(w, h); break;
          }
        }

        requestAnimationFrame(animate);
      };

      animate();
    }
  }
</script>
